# Лабораторная работа №2 — Префиксный multiset (OCaml)
Жук И. А., isu: 408614, P3315

- Вариант:
  - `pre-bag` — неизменяемый мультимножество на основе префиксного дерева (trie).

## Описание задачи

Во второй лабораторной нужно разработать полиморфную неизменяемую структуру данных, поддерживающую добавление/удаление элементов, `filter`, `map`, обе свёртки, операции моноида и полноценное тестирование (юнит + property-based). В рамках выбранного варианта реализован префиксный `bag`, в котором ключ разбивается на упорядоченные фрагменты, а хранение ведётся в узлах префиксного дерева. Требования из `task.md` закрываются следующим образом:

1. Базовые операции (`add`, `remove`, `mem`, `count`, `size`, `to_list`) работают с учётом кратности элементов.
2. `filter`, `map`, `fold_left`, `fold_right` позволяют обрабатывать коллекцию без нарушения неизменяемости.
3. `union` образует моноид с нейтральным `empty` и проверенной ассоциативностью.
4. Структура полиморфна и определяется функтором `Pre_bag.Make`, принимающим реализацию `KEY`.
5. Для всего API написаны модульные тесты и свойства Alcotest.

## Реализация (ключевые элементы)

- `lib/pre_bag.mli` описывает контракт:
  - `module type KEY` задаёт элемент `t`, его часть `part`, разбиение `parts : t -> part list`, полный порядок на частях и равенство элементов; так обеспечивается работа tries для любых ключей (строки, списки токенов и т.д.).
  - `module type S` определяет публичный интерфейс мультимножества (конструкторы, запросы, свёртки, преобразования).
  - `module Make (Key : KEY)` предоставляет реально используемый модуль `Bag`.
- `lib/pre_bag.ml` — реализация trie:
  - Узлы дерева: `type node = { count : int; value : elt option; children : node PartMap.t }`. `count` хранит кратность элемента, `value` фиксирует сам элемент в листьях, а `PartMap` (на базе `Map.Make`) обеспечивает сортировку ветвей по `part`.
  - Добавление разбивает ключ на фрагменты и при необходимости создаёт дочерние узлы; кратность и общий счётчик обновляются одним проходом:

    ```ocaml
    let add elt { total; root } =
      let rec add_parts parts node =
        match parts with
        | [] -> { node with count = node.count + 1; value = Some elt }
        | part :: rest ->
            let child = PartMap.find_opt part node.children |> Option.value ~default:empty_node in
            let updated = add_parts rest child in
            { node with children = PartMap.add part updated node.children }
      in
      { total = total + 1; root = add_parts (Key.parts elt) root }
    ```

  - Удаление проходит по тем же частям, уменьшает `count` и при нуле удаляет ветку, чтобы не захламлять trie.
  - `union` реализован через рекурсивное слияние поддеревьев, что даёт моноидную операцию без преобразования к спискам:

    ```ocaml
    let rec merge_nodes left right =
      let children =
        PartMap.merge (fun _ l r -> match (l, r) with
          | None, None -> None
          | Some c, None | None, Some c -> Some c
          | Some l, Some r -> Some (merge_nodes l r))
          left.children right.children
      in
      let count = left.count + right.count in
      let value =
        match (left.value, right.value) with
        | Some v, _ when left.count > 0 -> Some v
        | _, Some v when right.count > 0 -> Some v
        | _ -> None
      in
      { count; value; children }
    ```

    Сам `union` просто складывает `total` и вызывает `merge_nodes`, а `equal` рекурсивно сравнивает соответствующие поддеревья через `Key.equal`.
  - `filter` и `map` строят новый bag через свёртку и повторное `add`, сохраняя иммутабельность; вспомогательные `apply_n`/`apply_n_right` гарантируют, что кратности считаются корректно при линейном/обратном обходе.

## Тестирование

- Unit-тесты (`test/test_pre_bag.ml`) на Alcotest покрывают счётчики, удаление, фильтрацию/отображение и обе свёртки. Используется конкретный `String_key`, разбивающий строку на символы.
- Property-based тесты описаны тем же файлом. Вспомогательная функция `check_property` запускает до 200 прогонов на псевдослучайных данных. Проверяются:
  - левый и правый нейтральные элементы для `union`;
  - ассоциативность `union`;
  - обратимость операции `add`/`remove` для одного элемента (удаление сразу после добавления возвращает исходный bag).
- Команда запуска: `dune test`. Она собирает библиотеку и запускает оба набора тестов.

## Сборка и форматирование

- `dune build` — сборка библиотеки.
- `dune fmt` — автоформатирование всех OCaml-модулей согласно настройке `(formatting (enabled_for ocaml))` из `dune-project`.
- `dune runtest`/`dune test` — запуск тестового набора (unit + property).

## Выводы

- Функторная реализация `Make` позволяет переиспользовать структуру для любых типов, которые можно разбить на сравнимые фрагменты.
- Префиксное дерево экономит память по сравнению с плоскими хэшами для «схожих» ключей и естественно поддерживает сортировку.
- Отказ от промежуточных списков (`fold` -> `add`) помогает сохранить инварианты иммутабельности и не упираться в GC.
- Property-based тесты быстро находит ошибки в реализациях моноидов, особенно при работе с подсчётом кратности.
